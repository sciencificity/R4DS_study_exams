---
title: "Chapter 1 - Data Viz with ggplot"
author: "Vebash Naidoo"
date: "10/08/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
library(tidyverse)
library(flair)
library(tidyquant)
theme_set(theme_tq())
```

## Do cars with big engines use more fuel than cars with small engines?

Hypothesis: Cars with bigger engines use more fuel, i.e. the fuel efficiency declines as the engine size gets bigger. If `miles per gallon` was on the y-axis and `engine size` on the x-axis we would see a decreasing trend.

```{r}
ggplot2::mpg

# create coordinate system
ggplot(data = mpg, aes(x = displ,
                       y = hwy))

ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ,
                           y = hwy))
```

My hypothesis has been confirmed.

```{r}
num_rows <- nrow(mtcars)
num_cols <- ncol(mtcars)
ex4_plot <- ggplot(data = mpg,
                   aes(x = hwy,
                       y = cyl)) +
  geom_point()
```

### Exercises

1.  Run `ggplot(data = mpg)`. What do you see? <br>
    Ans: An empty canvas of a plot. If you add the 
    `aes(x = xx, y = yy)` you will see an empty canvas with 
    the axes drawn.

1.  How many rows are in `mtcars`? How many columns? <br>
    Ans: Number of rows is `r num_rows`, cols is `r num_cols`.
  
1.  What does the `drv` variable describe?  Read the help 
    for `?mpg` to find out. <br>
    Ans: 'The type of drive train, where f = front-wheel drive, 
    r = rear wheel drive, 4 = 4wd'
    
1.  Make a scatterplot of `hwy` vs `cyl`.
    ```{r}
    ex4_plot
    ```

1.  What happens if you make a scatterplot of `class` vs `drv`? Why is
    the plot not useful?
    
    ```{r}
    ggplot(data = mpg, aes(x = class, 
                         y = drv)) +
    geom_point()    
    ```
    These are 2 categorical variables here so this isn't very useful.

## Aesthetics

You can give extra information about your dataset by mapping data to aesthetics like `size`, `colour`, `shape`.

```{r aes1, include=FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, 
                           colour = class))
```

```{r, echo = FALSE}
decorate("aes1") %>% 
  flair("colour = class", background = "#9FDDBA", 
        color = "#008080")
```

When you put a feature against an aesthetic `ggplot` will assign a unique `level` (here <span style="color: #008080;background-color:#9FDDBA">colour</span> to each <span style="color: #008080;background-color:#9FDDBA">class</span> of the feature) -> this process is called `scaling`.

```{r size_aes, include=FALSE}
ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy,
                 size = class))
```

```{r, echo=FALSE}
decorate("size_aes") %>% 
  flair("size = class", background = "#800000", 
        color = "#FFE4E1")
```

Mapping a unordered variable like `class` to an <span style="color: #FFE4E1;background-color:#800000">ordered aesthetic</span> like `size` is not a good idea, and we get a <span style="color: #FFE4E1;background-color:#800000">warning</span> here.

```{r alpha_aes, include=FALSE}
ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy,
                 alpha = class))
```

```{r, echo=FALSE}
decorate("alpha_aes") %>% 
  flair("alpha = class", background = "#9FDDBA", 
        color = "#008080")
```

<span style="color: #008080;background-color:#9FDDBA">`alpha`</span> is another aesthetic that we can use.

```{r shape_aes, include=FALSE, warning=TRUE}
ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy,
                 shape = class))
```

```{r, echo=FALSE}
decorate("shape_aes") %>% 
  flair("shape = class", background = "#800000", 
        color = "#FFE4E1")
```

`ggplot` only uses **6** <span style="color: #FFE4E1;background-color:#800000">`shape`</span>s at a time, so we're missing `suv`! When mapping to aesthetics think carefully about which aesthetic makes sense.

If you look at the `colour = class` plot vs the `shape = class` plot you may well think - it looks like previously labelled `suv` is now being considered to be `pickup`!? There are many points and the points get plotted on top of each other - if you look near `displ = 5 and hwy = 12` notice that there is an `pickup` point there ... previously there was an `suv` point there. Let's jitter the data so that the points lie a little away from each other to show that there's not any issue with `ggplot`, instead the data lying on top of each other shows the last `class`.

```{r}
ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy,
                 colour = class))

ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy,
                 shape = class))

ggplot(data = mpg) +
  geom_jitter(aes(x = displ, y = hwy,
                 colour = class))

ggplot(data = mpg) +
  geom_jitter(aes(x = displ, y = hwy,
                 shape = class))
```

Occassionally you may want to change all the points sizes uniformly (irrespective of any other data feature) - in this case you may put the aesthetic on the outside of the `aes()`.

```{r uniform_col, include=FALSE}
ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy),
             colour = "blue")
```

```{r, echo = FALSE}
decorate('uniform_col') %>% 
  flair('colour = "blue"', 
        background = "#e5989b", 
        color = "#6d6875")

```

```{r uniform_size, include=FALSE}
ggplot(data = mpg) +
  geom_point(aes(x = displ, 
                 y = hwy),
             size = 4)
```

```{r, echo = FALSE}
decorate('uniform_size') %>% 
  flair("size = 4", 
        background = "#e5989b", 
        color = "#6d6875")

```

### Exercises

#### Exercise 1

What's gone wrong with this code? Why are the points not blue?
    
```{r ex1, include=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
```
```{r, echo=FALSE}
decorate("ex1") %>% 
  flair('color = "blue"',
        background = "#800000", 
        color = "#FFE4E1")
```
The <span style="color:#FFE4E1;background-color:#800000">`color`
</span> attribute maps to a static colour `blue` and yet 
appears within
`aes()`.
To correct, put `colour = 'blue'` outside the `aes()`

```{r ex1_correct, include=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, 
                           y = hwy), 
             color = "blue")
```
```{r, echo=FALSE}
decorate("ex1_correct") %>% 
  flair('color = "blue"',
        background = "#e5989b", 
        color = "#6d6875")
```

<br><br>

#### Exercise 2

Which variables in `mpg` are categorical? Which variables are continuous? 
(Hint: type `?mpg` to read the documentation for the dataset). How
can you see this information when you run `mpg`?

  `manufacturer`, `model`, `trans`, `drv`, `fl` and `class` are
    categories (I also think `cyl` may be considered a category since it
    takes on 4 values based on a limited number of cylinders); `displ`,
    `year`, `cty`, `hwy`, `cyl` are continuous. You can convert `mpg` to a
    tibble (if it is not already) and check the types using `glimpse()`.
```{r}
glimpse(mpg)
```
<br><br>

#### Exercise 3

Map a continuous variable to `color`, `size`, and `shape`. How do
these aesthetics behave differently for categorical vs. continuous
variables? 

```{r}
ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy, 
                 colour = cyl))

ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy, 
                 colour = cty))
```

The colours are scaled from the lowest to the highest value 
using dark to light blue.
<br><br>

#### Exercise 4

What happens if you map the same variable to multiple aesthetics? 
```{r ex4_gg, include = FALSE}
ggplot(data = mpg) +
  geom_point(aes(x = displ, y = hwy,
                 colour = class,
                 size = class))
```

```{r, echo=FALSE}
decorate("ex4_gg") %>% 
  flair("colour = class",
        background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("size = class",
        background = "#9FDDBA", 
        color = "#008080")
```
Here we have both 
<span style="color:#008080;background-color:#9FDDBA">`colour` and
`size`</span> mapped to `class`. The plot offers no new information
with the second aesthetic so I'd consider it a poor plot. You should
use aesthetics mapped to different features in your data to meet with
the **Axiom** that _'The greatest value of a picture is when it 
forces us to notice what we never expected to see. 
--John Tukey'_ as mentioned in the beginning of the 
__Aesthetic Mappings__ section!
<br><br>

#### Exercise 5

What does the `stroke` aesthetic do? What shapes does it work with?
(Hint: use `?geom_point`)

__Tip: Did you know that when you call `?geom_point` you can go to an
example and highlight it, press 'Ctrl + Enter' and it will place that
example in your console and run it?__ <br>

<img src = assets/help_ctrl_enter.PNG width = 250px> <br>

<img src = assets/ctrl_enter_example_help_file2.gif>

```{r}
# For shapes that have a border (like 21), you can colour the inside and
# outside separately. Use the stroke aesthetic to modify the width of the
# border
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(shape = 2, colour = "black", fill = "white", size = 5, stroke = 5)

ggplot(mtcars, aes(wt, mpg)) +
  geom_point(shape = 23, colour = "black", fill = "white", size = 5, stroke = 3)
```

<img src = assets/shape.PNG>

Stroke changes the border width as described in the example comment,
and works with any shape that has a border hence will work with shapes
`0-14`, and `21-24`. An example of each is above.
<br><br>

#### Exercise 6

What happens if you map an aesthetic to something other than a variable 
name, like `aes(colour = displ < 5)`?  Note, you'll also need to specify x and y.

```{r ex6_gg, include = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = 
    aes(x = displ, 
        y = hwy, 
        colour = 
          (displ < 5)
        )
  )
```

```{r, echo=FALSE}
decorate("ex6_gg") %>% 
  flair("colour =",
        background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("(displ", 
          background = "#9FDDBA", 
          color = "#008080") %>% 
  flair_rx(" \\< 5\\)", 
          background = "#9FDDBA", 
          color = "#008080")
```

Points are split according to the criteria 
<span style="color: #008080;background-color:#9FDDBA">`displ < 5`</span>
and are coloured differently depending on what value they have 
for displacement.
<br><br>

## Facets
Another way to add information on your plot is to use `facets`. 

- `facet_wrap()` allows faceting by a single variable

  * First argument is a formula `~ var_name`
  * Variable passed in should be discrete.
  
- `facet_grid()` allows the faceting by 2 variables.

  * `var_name1 ~ var_name2`
  
```{r facet1, include=FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ,
                           y = hwy)) +
  facet_wrap(~ class, nrow = 2)
```

```{r, echo=FALSE}
decorate("facet1") %>% 
  flair("facet_wrap(~ class, nrow = 2)", 
        background = "#9FDDBA", 
        color = "#008080")
```

```{r facet2, include=FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ,
                           y = hwy)) +
  facet_grid(drv ~ class)
```

```{r, echo=FALSE}
decorate("facet2") %>% 
  flair("facet_grid(drv ~ class)", 
        background = "#9FDDBA", 
        color = "#008080")
```

### Exercises

#### Facets: Exercise 1
What happens if you facet on a continuous variable?

```{r facet_ex1, include=FALSE}
ggplot(data = mpg) +
  geom_point(aes(x = displ,
                 y = hwy)) +
  facet_wrap(~ cty)
```

```{r, echo=FALSE}
decorate("facet_ex1") %>% 
  flair("facet_wrap(~ cty)", 
        background = "#800000", 
        color = "#FFE4E1")
```

The plot is created but it doesn't make sense to split our data 
by a continuous variable. 
<br><br>

#### Facets: Exercise 2
What do the empty cells in plot with `facet_grid(drv ~ cyl)` mean? How do they relate to this plot?

The empty spots refer to that `drv and cyl combination` being missing.

```{r facet_ex2}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = drv, y = cyl))
```

It relates to the above in that you can see that the 
`drv = 4; cyl = 5` combination has no observations. 
This is also the case in the faceted plot.

#### Facets: Exercise 3
What plots does the following code make? What does . do?

```{r fct3_1, include=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)

```
    
```{r fct3_2, include=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)
```
    
```{r, echo=FALSE}
decorate("fct3_1") %>% 
  flair("facet_grid(drv ~ .)", 
        background = "#9FDDBA", 
        color = "#008080")
```

The <span style="color: #008080;background-color:#9FDDBA">`facet_grid
(drv ~ .)`</span> facets the `drv` categories into rows. It says 
facet this plot by `drv` as row panels but I don't want anything 
as column panels (hence the `.`).
  
```{r, echo=FALSE}
decorate("fct3_2") %>% 
  flair("facet_grid(. ~ cyl)", 
        background = "#9FDDBA", 
        color = "#008080")
```

The <span style="color: #008080;background-color:#9FDDBA">`facet_grid(. ~ cyl)`</span> facets the `cyl` categories into columns. It says facet this plot by `cyl` as column panels but I don't want anything as row panels (hence the `.`).
  
#### Facets: Exercise 4  
Take the first faceted plot in this section:

```
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)

```
What are the advantages to using faceting instead of the colour aesthetic? What are the disadvantages? How might the balance change if you had a larger dataset?

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

* What are the advantages to using faceting instead of the colour aesthetic? <br>
You can see the patterns in each class much easier.

* What are the disadvantages? <br>
You may lose sight of the overall trend across all observations, and comparing categories becomes more "work".

* How might the balance change if you had a larger dataset? <br>
If you have many categories it becomes overwhelming.

#### Facets: Exercise 5
Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? Why doesnâ€™t facet_grid() have nrow and ncol arguments? <br>
From the help page these are the main aspects that alter your visuals.

* `nrow` and `ncol` specify the number of rows or columns you're looking for in your plot.
* `scales`: Should scales be fixed ("fixed", the default), free ("free"), or free in one dimension ("free_x", "free_y")?
* Use the `labeller` option to control how labels are printed.
* Use `strip.position` to display the facet labels at the side of your choice. Setting it to `bottom` makes it act as a subtitle for the axis. This is typically used with free scales and a theme without boxes around strip labels.

#### Facets: Exercise 6
When using facet_grid() you should usually put the variable with more unique levels in the columns. Why? <br>
I would think this orientation makes best use of the screen real estate available.
<br><br>

## Geometric Objects

```{r, echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

```{r plots, echo = FALSE, out.width = "50%", fig.align="default", message = FALSE, include=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

```{r, echo=FALSE}
decorate("plots") %>% 
  flair("geom_point",
        background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("geom_smooth",
        background = "#9FDDBA", 
        color = "#008080")

```


The above plots are made using the same data, but the <span style="color: #008080;background-color:#9FDDBA">`geoms`</span> are different. To change the plot type i.e. `bar`, `boxplot`, `line` etc. you just <span style="color: #008080;background-color:#9FDDBA">change the `geom` you add to `ggplot`.</span> The `aesthetics` that work with each `geom` is different however. E.g. you may set the <span style="color: #008080;background-color:#9FDDBA">`linetype`</span> of a line, but you __can't__ change the <span style="color: #FFE4E1;background-color:#800000">`shape` of a line.</span>

```{r linetype1, include=FALSE}
ggplot(data = mpg) +
  geom_line(aes(x = displ, y = hwy, linetype = drv))
```

```{r, echo=FALSE}
decorate("linetype1") %>% 
  flair("linetype = drv",
        background = "#9FDDBA", 
        color = "#008080")
```


```{r linetype2, include=FALSE}
ggplot(data = mpg) +
  geom_smooth(aes(x = displ, y = hwy, linetype = drv))
```

```{r, echo=FALSE}
decorate("linetype2") %>% 
  flair("linetype = drv",
        background = "#9FDDBA", 
        color = "#008080")
```

```{r two_geoms1, include=FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, colour = drv)) +
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv, colour = drv))

```

```{r, echo=FALSE}
decorate("two_geoms1") %>% 
  flair("geom_point(mapping = aes(x = displ, y = hwy, colour = drv))",
        background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv, colour = drv))",
        background = "#9FDDBA", 
        color = "#008080")
```

We are also able to add more than <span style="color: #008080;background-color:#9FDDBA">one geom</span> on a plot. In the above we show both the <span style="color: #008080;background-color:#9FDDBA">raw data points</span> coloured by the drive type - e.g. 4 wheel, rear drive or front wheel, as well as each drive types <span style="color: #008080;background-color:#9FDDBA">smoothing line</span>. But the downside to the above is that I had to specify the `mapping` twice with many repeated elements. To avoid this `ggplot` provides a handy alternate - you may set the `mapping` in the `ggplot()` call itself - the `mapping` is treated as __global__ to all subsequent `geoms` unless you specifically override these.

```{r two_geoms2, include=FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, colour = drv)) +
  geom_point() +
  geom_smooth(mapping = aes(linetype = drv))
```

```{r, echo = FALSE}
decorate("two_geoms2") %>% 
  flair("mapping = aes(x = displ, y = hwy, colour = drv)", 
        background = "#9FDDBA", 
        color = "#008080") 
```

Also in the above you may have noticed that <span style="color: #008080;background-color:#9FDDBA">`geom_smooth()`</span> included it's own mapping. This basically says _'Hey, take all the attributes as per the ggplot mapping BUT replace these components (if it exists) as described in this geom'._

```{r spec_override1, include=FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(mapping = aes(colour = class)) +
  geom_smooth()
```

```{r, echo = FALSE}
decorate("spec_override1") %>% 
  flair("mapping = aes(x = displ, y = hwy)",
        background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("mapping = aes(colour = class)",
        background = "#9FDDBA", 
        color = "#008080")
```
For example here when it gets to the <span style="color: #008080;background-color:#9FDDBA">__geom_point(mapping = aes(colour = class))__</span> line it asks:

1. Does this mapping specify a new `x`? It doesn't, so `x = displ` is set, as per the `ggplot()` `mapping()`.
1. Does this mapping specify a new `y`? It doesn't, so `y = hwy` is set, as per the `ggplot()` `mapping()`.
1. Is there anything extra set? Yip, `colour = class` is set, so let me apply that to this `geom_point`'s only, hence the scatterpoint plots are coloured by the `class` of the vehicle.

You may also __even__ change the __data__ for each layer! Here the `smoothing` function is included but for a subset of the data.

```{r spec_override2, include=FALSE}
ggplot(data = mpg, aes(x = displ, y = hwy)) +
  geom_point(mapping = aes(colour = class)) +
  geom_smooth(
    data = filter(mpg, class == "subcompact"),
    se = FALSE # remove the error bands that display around the line
  )
```

```{r, echo = FALSE}
decorate("spec_override2") %>% 
  flair('data = filter(mpg, class == "subcompact")', 
        background = "#9FDDBA", 
        color = "#008080")
```

### Exercises

1.  What geom would you use to draw a line chart? A boxplot? 
    A histogram? An area chart?
    
    * line chart: geom_line()
    * boxplot: geom_boxplot()
    * histogram: geom_histogram()
    * Area chart: geom_area()
    
1.  Run this code in your head and predict what the output will look like.
    Then, run the code in R and check your predictions.
    
    ```{r, eval = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ```
    In my head this will produce a scatterplot with `displ` on the x-axis,
    `hwy` on the y-axis where each point is coloured by the 
    type of `drive` the vehicle is (4 wheel, front-wheel, rear-wheel). 
    The plot will also contain smoothing lines (with no error bands) 
    for each drive type (since `colour` is set in the `ggplot` 
    mapping layer, and is applicable for both points, and the 
    smoothing lines).
    
    ```{r, eval = TRUE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ```    
1.  What does `show.legend = FALSE` do?  What happens if you remove it?  
    Why do you think I used it earlier in the chapter?   
    
    It removes the legend that shows up when we add certain aesthetics
    such as `colour`, `shape` etc.
    
    If we remove it the legend will show by the fact that a certain non-xy 
    aesthetic has been added.
    
    It was used to remove the legend earlier which would have shown up due to
    the `colour = drv` aesthetic.

1.  What does the `se` argument to `geom_smooth()` do?
    It sets the errors bands on the smoothing function to either on or off.
    

1.  Will these two graphs look different? Why/why not?

    ```{r, eval = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point() + 
      geom_smooth()
    
    ggplot() + 
      geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
    ```
    They will look the same. In the first plot the `data = mpg, mapping = aes(x = displ, y = hwy)`
    will be inherited by both `geom_point()` and `geom_smooth()`.
    In the second plot the `data = mpg, mapping = aes(x = displ, y = hwy)` is repeated 
    in each geom and hence both plots will be the same.
    
    ```{r, out.width = "50%", fig.align="default", message = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point() + 
      geom_smooth()
    
    ggplot() + 
      geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
    ```
    
1.  Recreate the R code necessary to generate the following graphs.
        
    ```{r}
    ggplot(data = mpg, aes(x = displ, y = hwy)) +
      geom_point(size = 2) +
      geom_smooth(se = FALSE)
    ```
    ```{r}
    ggplot(data = mpg, aes(x = displ, y = hwy)) +
      geom_point(size = 2) +
      geom_smooth(aes(group = drv), se = FALSE)
    ```
    ```{r}
    ggplot(data = mpg, aes(x = displ, y = hwy, colour = drv)) +
      geom_point(size = 2) +
      geom_smooth(se = FALSE)
    ```
    ```{r}
    ggplot(data = mpg, aes(x = displ, y = hwy)) +
      geom_point(aes(colour = drv)) +
      geom_smooth(se = FALSE)
    ```
    ```{r}
    ggplot(data = mpg, aes(x = displ, y = hwy)) +
      geom_point(aes(colour = drv)) +
      geom_smooth(aes(linetype = drv), se = FALSE)
    ```
    ```{r}
    ggplot(data = mpg, aes(x = displ, y = hwy)) +
      geom_point(size = 3, colour = "white") +
      geom_point(aes(colour = drv))
    ```

## Statistical Transformations or `stat`

Some plots do statistical transforms in the background. 

- For example `bar charts`, `histograms`
and `frequency plots` count or bin the data. 
- There's also `boxplots` which computes the
distribution and plots them.
- Smoothing functions which we've see fit a model to the
data and plots that.

Want to check what transform happens behind the scene? Call up the help page.

- `?geom_boxplot` shows that the `stat = boxplot`
- `?geom_bar` shows that the `stat = count`

```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut))
```

You can recreate the above by using the `stat`:

```{r}
ggplot(data = diamonds) +
  stat_count(mapping = aes(x = cut))
```

You may want to override the default mapping. For example here we
get the proportion.

```{r}
ggplot(data = diamonds) +
  geom_bar(
    mapping = aes(x = cut, y = ..prop.., group = 1)
  )
```

```{r}
ggplot(data = diamonds) +
  stat_summary(mapping = aes(x = cut, y = depth),
               fun.min = min,
               fun.max = max,
               fun = median)
```

### Exercises

1.  What is the default geom associated with `stat_summary()`? How could
    you rewrite the previous plot to use that geom function instead of the 
    stat function?
    
    `geom_pointrange`. <br>
    We can use the geom, the summary statistics need to be computed however.
    You can either do this in the function by using `stat = 'summary'` or
    you can summarise the data first and then pass it in as arguments. The
    reason for this is because the `stat` of `geom_pointrange` is
    [`identity`](https://ggplot2.tidyverse.org/reference/stat_identity.html)
    which does __NOT__ change the data.
    
    In the code below you will see a new operation that we have not talked about:
    `%>%` which is called the pipe operator, we tackle this later in R4DS. For now
    when you see _%>%_ read it as `and then` e.g. _Take this df **and then** group
    it by this criterion, **and then** show me a summary._
    
    <pre>
      df <span style="color: #008080;background-color:#9FDDBA">%>%</span> 
        group_by(this_characteristic) <span style="color: #008080;background-color:#9FDDBA">%>%</span> 
        summary(mean_characteristic = mean(characteristic))
    </pre>
    
    ```{r}
    ggplot(data = diamonds) +
      geom_pointrange(mapping = aes(x = cut, y = depth),
                      stat = 'summary',
                      fun.min = min,
                      fun.max = max,
                      fun = median)
    ```
    ```{r}
    diamonds_amended <- diamonds %>% 
      group_by(cut) %>% 
      summarise(y_med = median(depth),
                y_min = min(depth),
                y_max = max(depth)) %>% 
      ungroup()
    
    ggplot(data = diamonds_amended) +
      geom_pointrange(mapping = aes(x = cut, y = y_med, ymin = y_min,
                      ymax = y_max))
    ```    
      

1.  What does `geom_col()` do? How is it different to `geom_bar()`? <br>
    Whereas `geom_bar()` bins the data - i.e. it counts how many occurrences
    there are for each value of `x`, `geom_col()` has `stat_identity()` as 
    its `stat` and therefore plots the actual y value - it leaves the data as is.

1.  Most geoms and stats come in pairs that are almost always used in 
    concert. Read through the documentation and make a list of all the 
    pairs. What do they have in common? <br>
    
    [Info here](https://ggplot2.tidyverse.org/reference/)
    

1.  What variables does `stat_smooth()` compute? What parameters control
    its behaviour? <br>
    It computes the predicted value of y etc. 
    [More info here](https://www.rdocumentation.org/packages/ggplot2/versions/0.9.0/topics/stat_smooth).

1.  In our proportion bar chart, we need to set `group = 1`. Why? In other
    words what is the problem with these two graphs?
    
    ```{r, eval = FALSE}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, y = ..prop..))
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))
    ```
    ```{r, eval = TRUE}
    plt1 <- ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, y = ..prop..))
    plt1_int <- ggplot_build(plt1)
    plt1_int$data[[1]]
    plt1
    plt2 <- ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))
    plt2_int <- ggplot_build(plt2)
    as_tibble(plt2_int$data[[1]])
    plt2
    ``` 
    
    In the first graph above each individual `cut` is considered as an 
    individual  group. 
    This means that the proportion = 1 since sum(count) over the group = count.
    
    In the second graph each individual `color` and `cut` is considered 
    as an individual group and the same occurs.
    
    In order to get the proportion using `..prop..` we need to tell ggplot
    how it must group our data. If we provide `group = 1` we're telling ggplot to 
    consider the data as one group. Now proportions are correctly created.
    
    ```{r, eval = TRUE}
    plt1 <- ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
    plt1_int <- ggplot_build(plt1)
    plt1_int$data[[1]]
    plt1
    ```     
    
  
## Position Arguments - Bar Charts

With bar charts you may colour the bar chart with the
<span style="color: #008080;background-color:#9FDDBA">`colour`</span>  or 
<span style="color: #008080;background-color:#9FDDBA">`fill`</span> argument.

```{r, echo = TRUE, eval = FALSE, message = FALSE}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, colour = cut))

ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, fill = cut))
```

```{r, echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, colour = cut))

ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, fill = cut))
```

That's not really useful. The power of using the <span style="color: #008080;background-color:#9FDDBA">`fill`</span> aesthetic is when
we fill the bar with <span style="color: #008080;background-color:#9FDDBA">another variable!</span> 

```{r fill1, include=FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```
    
```{r, echo=FALSE}
decorate("fill1") %>% 
  flair("fill = clarity", 
        background = "#9FDDBA", 
        color = "#008080")
```

The `position` argument does the stacking (the default). You can change this
by using: 

- identity
- dodge
- fill

#### position = 'identity'
Places the object exactly where it falls on the graph. 
Bars overlap in this case which is not too useful.
We can see the overlap by setting <span style="color: #008080;background-color:#9FDDBA">`alpha = some_small_value`</span> or
<span style="color: #008080;background-color:#9FDDBA">`fill = NA`</span>.

*Useful for 2d geoms like points where it's the default.*

```{r pos1, include=FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity),
           alpha = 1/5, position = 'identity')
```
    
```{r, echo=FALSE}
decorate("pos1") %>% 
  flair("alpha = 1/5, position = 'identity'", 
        background = "#9FDDBA", 
        color = "#008080")
```

```{r pos2, include=FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = clarity),
           fill = NA, position = 'identity')
```
    
```{r, echo=FALSE}
decorate("pos2") %>% 
  flair("fill = NA, position = 'identity'", 
        background = "#9FDDBA", 
        color = "#008080")
```

#### position = 'fill'

Similar to stacking but it makes all bars the same height,
and is thus good for comparisons.

```{r pos3, include=FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity),
           position = 'fill')
```
    
```{r, echo=FALSE}
decorate("pos3") %>% 
  flair("position = 'fill'", 
        background = "#9FDDBA", 
        color = "#008080")
```

#### position = 'dodge'

Instead of stacked bars each individual fill variable is plotted in
its own bar - i.e. objects are placed alongside each other.


```{r pos4, include=FALSE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity),
           position = 'dodge')
```
    
```{r, echo=FALSE}
decorate("pos4") %>% 
  flair("position = 'dodge'", 
        background = "#9FDDBA", 
        color = "#008080")
```

## Position Arguments - Scatterplot

Remember that points have a default position of identity - i.e. plot it
where it falls. When there are many points though this gets hidden as
points are plotted on top of each other and we see this as a single point
when in fact there may be multiple points that fall in that exact x, y spot.

Enter <span style="color: #008080;background-color:#9FDDBA">`position = 'jitter'`</span>  which provides a slight displacement of a point
so that the viewer can see the individual points. You can also get this sometimes
with setting `alpha` if the points are concentrated in some pockets.

```{r pos5, include=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```
    
```{r, echo=FALSE}
decorate("pos5") %>% 
  flair("geom_point", 
        background = "#9FDDBA", 
        color = "#008080")
```

```{r pos6, include=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy),
             position = 'jitter')
```
    
```{r, echo=FALSE}
decorate("pos6") %>% 
  flair("geom_point", 
        background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("position = 'jitter'", 
        background = "#9FDDBA", 
        color = "#008080")   
```

```{r pos7, include=FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy),
             alpha = 0.2)
```
    
```{r, echo=FALSE}
decorate("pos7") %>% 
  flair("geom_point", 
        background = "#9FDDBA", 
        color = "#008080") %>% 
  flair("alpha = 0.2", 
        background = "#9FDDBA", 
        color = "#008080")   
```

### Exercises

<ol>

<li> What is the problem with this plot? How could you improve it?

```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_point()
```
    It is overplotting: where points fall in the same x, y spot, or close enough.
    We can try jittering the points.
    
```{r pos8, include=FALSE}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_jitter()
```
    
```{r, echo=FALSE}
decorate("pos8") %>% 
  flair("geom_jitter()", 
        background = "#9FDDBA", 
        color = "#008080") 
```
</li>

<li> What parameters to `geom_jitter()` control the amount of jittering? <br>
    `width` and `height` tell ggplot how much of jitter in the horizontal
    and vertical position should be added.
</li>
<li>Compare and contrast `geom_jitter()` with `geom_count()`.<br>
    `geom_count()` counts the number of observations at each location 
    and adds the count at the position.<br>
    `geom_jitter()` adds some random noise to each point so that we can
    see the individual points better but the points don't actually fall at
    that location.
```{r pos9, include=FALSE}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_jitter()
```
    
```{r, echo=FALSE}
decorate("pos9") %>% 
  flair("geom_jitter()", 
        background = "#9FDDBA", 
        color = "#008080") 
```

    
```{r pos10, include=FALSE}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_count()
```
    
```{r, echo=FALSE}
decorate("pos10") %>% 
  flair("geom_count()", 
        background = "#9FDDBA", 
        color = "#008080") 
```
</li>
<li> 
What's the default position adjustment for `geom_boxplot()`? Create
a visualisation of the `mpg` dataset that demonstrates it. <br>
    
  `position = "dodge2"`  
  Dodging usually introduces adjustments along the horizontal axis.
  This position allows vertical adjustments too for boxplots.
    
```{r pos11, include=FALSE}
# examples from geom_boxplot help page
ggplot(mpg, aes(hwy, manufacturer)) + geom_boxplot()
p <- ggplot(mpg, aes(hwy, class))
p + geom_boxplot()
# Boxplots are automatically dodged when any aesthetic is a factor
p + geom_boxplot(aes(colour = drv))
```

```{r, echo=FALSE}
decorate("pos11") %>% 
  flair("geom_boxplot()", 
        background = "#9FDDBA", 
        color = "#008080") 
```

</li>
</ol>

## Coordinate systems

The default coordinate system is the Cartesian Plane. 
There are few other types of coordinate systems. 

<ol>
<li>
`coord_flip()` - not needed really since `ggplot version 3.0.0`.

<img src = assets/no_longer_coord_flip1.PNG width = 500px> <br> 

<img src = assets/no_longer_coord_flip2.PNG width = 500px> <br> 

</li>
<li>
`coord_quickmap()` - sets correct aspect ratio for maps.
```{r}
nz <- map_data("nz")
ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")
ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()
```
</li>

<li>
`coord_polar()` - uses polar coords - useful for pie charts.
```{r}
bar <- ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, fill = cut), 
    show.legend = FALSE,
    width = 1
  ) + 
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL)

bar + coord_flip()
bar + coord_polar()
```
</li>
</ol>

### Exercises

1.  Turn a stacked bar chart into a [pie chart](https://www.displayr.com/how-to-make-a-pie-chart-in-r/) using `coord_polar()`.<br>
    ```{r}
    ggplot(data = mpg) +
      geom_bar(mapping = aes(x = class))
    ```
    
    ```{r}
    ggplot(data = mpg) +
      geom_bar(mapping = aes(x = "", fill = class)) +
      coord_polar(theta = 'y')
    ```

1.  What does `labs()` do? Read the documentation. <br>
    Adds labels to a plot for things like title, x-axis etc.

1.  What's the difference between `coord_quickmap()` and `coord_map()`?<br>
    From help page of coord_map: <br>
    coord_map projects a portion of the earth, which is approximately 
    spherical, onto a flat 2D plane using any projection defined by the mapproj
    package. Map projections do not, in general, preserve straight lines, so this
    requires considerable computation. coord_quickmap is a quick approximation
    that does preserve straight lines. It works best for smaller areas closer to
    the equator.
    ```{r}
    ggplot(nz, aes(long, lat, group = group)) +
      geom_polygon(fill = "white", colour = "black") +
      coord_quickmap()
    ```
    
    ```{r}
    ggplot(nz, aes(long, lat, group = group)) +
      geom_polygon(fill = "white", colour = "black") +
      coord_map()
    ```


1.  What does the plot below tell you about the relationship between city
    and highway mpg? Why is `coord_fixed()` important? What does 
    `geom_abline()` do?
    
    ```{r, fig.asp = 1, out.width = "50%"}
    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
      geom_point() + 
      geom_abline() +
      coord_fixed()
    ```
    The `geom_abline()` adds a 45 degree line to the plot. 
    The `coord_fixed()` with no arguments sets the ratio 
    between y and x to 1. This means that the y:x representation is 1:1.
    






















